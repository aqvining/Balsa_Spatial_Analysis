---
title: "Spatial-Temporal Distribution of Kinkajous in a Balsa Tree"
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
---

# Overview

The analysis in this document seeks to answer the question "What factors influence the movements of kinkajous within the crown of a balsa tree?". We start with a few hypotheses:

A. Kinkajous prefer to forage in regions with greater densities of flowers

B. Kinkajous assess the density of flowers within a region through perception and/or sampling effort.

C. Kinkajous predict which regions will have more flowers using information obtained from foraging on previous nights

D. Kinkajous will avoid direct foraging competition with other kinkajous

E. Kinkajous remember where they have been and avoid foraging in recently depleted regions

To test these hypotheses, we collected data on the location of flowers within a balsa tree crown each night, and the locations of kinkajous within that crown every minute for four-hour periods. In order to conduct a spatial analysis, we divided the tree crown into three regions. As best as possible, these regions divided the crown such that all the offshoots of one or more primary branches were contained within a single region. We then tested how the spatio-temporal distribution of flowers within these regions related to the residence times of kinkajous within each region, and to the transitions of kinkajous between regions.

In this document, we 1) prepare and clean the data, 2) Develop predictions about the relationships between flower counts, kinkajou presence, and kinajous movements within and between regions, 3) visualize these relationships, and 4) develop and run statistical models to test predictions that appear to be supported by patterns in the data.

# Data Setup

```{r, setup, include=FALSE}
library(stringr)
library(readr)
library(tidyr)
library(lubridate)
library(sf)
library(dplyr)
library(ggplot2)
library(gplots)
library(ggridges)
library(scales)
library(nlme)
library(brms)
library(corrplot)
```

```{r helper_functions, include=FALSE}
get_study_day_and_time <- function(Datetime_string, study_start) {
  #study start must include the approximate start time of evening observations if overnight follows are to be binned into the correct study day
  datetime_vector <- strsplit(Datetime_string, split = "")[[1]]
  date1 <- paste(paste(datetime_vector[1:6], collapse = ""), 
                "20", 
                paste(datetime_vector[7:8], collapse = ""), sep = "") %>% as.POSIXct(format = "%d-%m-%Y", tz = "America/Panama")
  time1 = paste(datetime_vector[9:10], collapse = "")
  study_day = difftime(date1, study_start, units = "days") %>% floor()
  return(list(study_day, time1))
}

get_kinkMinutesPerHour <- function(count_data, categories = 6) {
  #default value for categories assumes count data has 6 rows per observational minute, representing 3 Regions x 2 states (hidden or visible)
  minutes_per_hour = (sum(count_data)/(length(count_data)/categories)) * 60
  return(minutes_per_hour)
}

get_growth_index <- function(time_series) {
  removed = 0
  while(time_series[1] == 0) {
    time_series <- time_series[-1]
    warning("initial observation removed due to value of 0")
    removed = removed + 1
  }
  growth_index <- ((time_series-time_series[1])/time_series[1]) * 100
  return(c(rep(NA, times = removed), growth_index))
}

get_decision_info <- function(transition_array, flower_data){
  # input:
    #transition_array: an array with regions transitioned from in one dimension, regions transitioned to in the second, and time in the third, where each cell gives the number of transitions that occured from region x to region y at time t
    #flower_data: a dataframe with columns Adjusted_Count and Region. Should only contains data from a singe study night
  decision_transitions <- apply(transition_array, MARGIN = 3, FUN = function(X) {X *matrix(c(0,1,1,0,                                                                                                                                                              1,0,1,0,                                                                                                                                                              1,1,0,0,
                                                                                             0,0,0,0),nrow = 4, ncol = 4)} ) %>%#this matrix is multiplied with a transition matrix to remove all transitions that are not from one region to a different region
    array(dim = dim(transition_array))
  
  if (sum(decision_transitions) <= 0) return(data.frame(matrix(ncol = 7, nrow = 0))) #if there are no decisions, returns a placeholder dataframe with 7 columns and 0 rows. Done to fit with the final form of the decision data.frame with columns for From, To, Minute, adj_flowers_to, Avoid, adj_flowers_avoid, and Study_night)
  #extract information about each decision in array
  decisions <- as.data.frame(which(decision_transitions > 0, arr.ind = TRUE)) #get array indices for all decisions
  #below, duplicate any rows where the same decisions was made more than once in a minute
  decisions <- data.frame(lapply(X = decisions, 
                                 FUN = rep, 
                                 times = mapply(function(data, dim1,dim2,dim3) data[dim1,dim2,dim3], dim1 = decisions$dim1, dim2=decisions$dim2, dim3=decisions$dim3, MoreArgs = list(data = decision_transitions))))
  names(decisions) <- c("From", "To", "Minute")
  decisions <- mutate(decisions, adj_flowers_to = arrange(flower_data, Region)$Adjusted_Count[To], #get the adjusted flower count of the region moved to for each decision.
                      Avoid = mapply(FUN = function(to, from){ which(! c(1,2,3) %in% c(to, from))}, to = To, from = From), #get the region avoided by checking the regions transitioned from and the the region transitioned to against the possible regions (1,2,3; not generalizable to more regions)
  )
  decisions <- mutate(decisions, adj_flowers_avoid = arrange(flower_data, Region)$Adjusted_Count[Avoid])
  return(decisions)
}
```

The data used for this analysis come from two sources: side-angle thermal video recordings of the balsa tree and top-down photographs of the tree captured by drone.

## Thermal Video Data Processing and Kinkajou Counts

The thermal videos are of the full balsa tree crown, recorded from the side. Most recordings were four hours, except where interrupted by rain. Recordings had outlines of the regions superimposed by Alexander Vining (using the software ProCreate), who previously diagrammed the full tree and observed kinkajous in the tree during all recordings. Because these files are large, they are not included in this repository. Instead, the data included here are the number of kinkajous in each region for each minute of a recording. These data are contained in the folder Kinkajou_Scans_Nele. The counts were determined by Nele Stockmeyer, who watched all of the thermal videos and scanned the tree each minute. Kinkajou counts are further annotated by the number of counted kinkajous that were not visible during the given scan, but their presence was inferred from other scans ("hidden").  Further details on the data collection process are contained in the manuscript ". . ."

In addition to the kinkajou counts, which are annotated by video-minutes, the file video_file_timestamp_metdata_cam1 contains the start and end timestamps of each video. These allow conversion of video-minutes to timestamps. 

We begin data preparation by determining the file names for all of the kinkajou count data, for which there is one .csv file per night of recording. We also parse the metadata file to store the start timestamps in a vector. We then read in each kinkajou count data file, convert the video-minutes to timestamps, and collect all of the data into a single dataframe.

```{r data_load, message = FALSE}
file_names <- dir("../DATA/raw/Kinkajou_Scans_Nele", pattern = ".csv")

video_metadata_location <- "../DATA/raw/Video_metadata/video_file_timestamp_metadata_cam1.txt"
video_metadata <- readChar(con = video_metadata_location, nchars = file.info(video_metadata_location)$size)
video_metadata <- str_split(video_metadata, pattern = "Folder: ")[[1]][-1] #break all metadata into strings for each observation period (and remove preceding empty character)
video_metadata <- str_split(video_metadata, pattern =  "start = ") #find the start time of all files
start_timestamps <- sapply(video_metadata, function(X) str_split(X[2], pattern = "\r")[[1]][1]) #extract start time of first file and remove all extra data
start_timestamps <- as.POSIXct(start_timestamps, format = "%Y-%m-%d_%H-%M-%S", tz = "GMT")
start_timestamps <- with_tz(start_timestamps, "America/Panama")


all_kinkajou_scans <-  c()
Jan_22_check = FALSE #used later to parse two video files that started on the same day (one AM one PM)

for(file_name in file_names) {
  scan_data <- read_csv(paste("../DATA/raw/Kinkajou_Scans_Nele/", file_name, sep = ""), skip = 1, progress = FALSE)
  colnames(scan_data) <- c("timestamp", "Region1_total", "Region1_hidden", "Region2_total", "Region2_hidden", "Region3_total", "Region3_hidden", "Kinkajou_Notes", "Video_Notes", "Extraneous")
  scan_data <- scan_data[complete.cases(scan_data$timestamp),] %>% select(! Extraneous)
  start_date <- str_split(file_name ,pattern = "_Cam")[[1]][1] #str_split returns a list of string components. We want the first (and only) element of this list - then the first string element in this list gives the date
  start_date <- as.POSIXct(paste("20", start_date, sep = ""), format = "%Y_%m_%d") #date needs all 4 digits
  start_timestamp <- start_timestamps[which(date(start_timestamps) == start_date)]
  #Two video files started on Jan 22nd, one AM and one PM. Because this is the ONLY date where this occurred, I implemented a quick and dirty check to parse the AM file first and the PM file second, below
  if (length(start_timestamp) > 1)
      if (! Jan_22_check) {
        start_timestamp <- start_timestamp[1]
        Jan_22_check <-  TRUE
      } else start_timestamp <- start_timestamp[2]
  #end Jan 22 case
  scan_data$timestamp <- start_timestamp + period_to_seconds(hms(scan_data$timestamp))
  scan_data$Study_night <- round(as.numeric(start_timestamp - start_timestamps[1], units = "days"), digits = 0)
  all_kinkajou_scans <- rbind(all_kinkajou_scans, scan_data)
}

head(all_kinkajou_scans)
```

We continue preparing the kinkajous count data by converting the data from a) total kinkajous per region and b) hidden kinkajous per region to a) visible kinkajous per region and b) hidden kinkajous per region. This makes analysis using either type of count separately easier.

```{r data_prep}
#convert empty count cells (NAs) to 0
count_data <- all_kinkajou_scans[,2:7] # columns 2 through 7 are the count data columns, we want NAs in the notes columns, but 0s in the count data
count_data[is.na(count_data)] <- 0
all_kinkajou_scans[,2:7] <- count_data

#The data as read contain the TOTAL number of kinkajous and the number of those total that are hidden. As suggested by the new names given to the columns in this data structure, we want the count of visible and hidden kinkajous, not the total. The adjustment is made below
all_kinkajou_scans <- mutate(all_kinkajou_scans, Region1_visible = Region1_total - Region1_hidden, Region2_visible = Region2_total - Region2_hidden, Region3_visible = Region3_total - Region3_hidden) %>% 
  select(timestamp, Region1_total, Region2_total, Region3_total, Region1_visible, Region1_hidden, Region2_visible, Region2_hidden, Region3_visible, Region3_hidden, Study_night, Kinkajou_Notes, Video_Notes)

#pivot dataframe to long format for easy usage in ggplot
all_kinkajou_scans_long <- pivot_longer(all_kinkajou_scans,
                                   cols = Region1_visible:Region3_hidden,
                                   names_to = c("Region", "Visibility"),
                                   names_sep = "_",
                                   values_to = "Count")

all_kinkajou_scans_long$Region <- sapply(all_kinkajou_scans_long$Region, switch, "Region1" = "1", "Region2" = "2", "Region3" = "3") %>% factor()

write.csv(all_kinkajou_scans_long, "../DATA/processed/all_kinkajou_scans.csv")
```

### Residence Times
With a quick operation, we also create a table of the total kinkajous-minutes spent in the whole crown and in each region on each night (where two kinkajous counted in the same regions during a scan consititutes two kinkajou-minutes
)
```{r nightly_kink_counts}
kinkajou_counts <- all_kinkajou_scans_long %>% group_by(Study_night) %>% summarise(Minutes_Per_Hour = get_kinkMinutesPerHour(Count)) %>% transform(Growth = get_growth_index(Minutes_Per_Hour))

kinkajou_counts_region <- all_kinkajou_scans_long %>% group_by(Study_night, Region) %>% summarise(Minutes_Per_Hour = get_kinkMinutesPerHour(Count, categories = 2)) %>% group_by(Region) %>% group_modify(~ transform(.x, Growth = get_growth_index(Minutes_Per_Hour)))
```
### Transitions

In addition to the counts of kinkajous in each region, we are interested in how kinkajous transition between regions. Thus, we use the count data to create a transition matrix for each scan, where the number in each cell denotes how many kinkajous moved from the region denoted by the row to the region denoted by the column. These transitions matrices are collated into an array for each study night, where the third dimension is the scan (video-minute). The arrays for each night are stored in a list.

```{r Get_transitions}

get_transitions <- function(count_data){
  #input: a dataframe with columns "Region1_total", "Region2_total", "Region3_total" and (optionally) "timestamp".
  #output: an array giving the number of transitions from one region (first dimension) to another (second dimension) for each minute (row) of the input data (third dimension)
  transitions <- array(data = 0, dim = c(4,4,nrow(count_data)))
  if("timestamp" %in% colnames(count_data)) arrange(count_data, timestamp)
  count_data <- select(count_data, Region1_total, Region2_total, Region3_total)
  for(i in 2:nrow(count_data)){
    #to calculate the transition matrix, we treat the counts in the previous timestep as the row totals of the transition matrix
    row_totals <- c(unlist(count_data[i-1,]),
                    max(sum(count_data[i,]) - sum(count_data[i -1,]), 0)) #create a fourth row total for kinkajous entering the tree by differencing the total kinkajou counts of the current timestep and the previous timestep, counting only positive differences.
    #we then treat the counts in the current timestep as the column totals in the transition matrix
    col_totals <- c(unlist(count_data[i,]),
                    max(sum(count_data[i-1,]) - sum(count_data[i,]), 0)) #create a fourth column total for kinkajous leaving the tree
    for(j in seq_along(row_totals)){
      for(k in seq_along(col_totals)){
        m <- min(row_totals[j], col_totals[k]) #m is the maximum number of transitions that can contribute to both the relevant row total and column total
        transitions[j,k,i] <- m
        row_totals[j] <- row_totals[j] - m #subtract the number of transitions that have been added from the corresponding row total
        col_totals[k] <- col_totals[k] - m #subtract the number of transitions that have been added from the corresponding column total
      }
    }
  }
  return(transitions)
}

transition_arrays <- all_kinkajou_scans %>% group_by(Study_night) %>% group_map(~get_transitions(.x))
names(transition_arrays) <- as.character(unique(all_kinkajou_scans$Study_night))
```

Because we only have counts, this method can sometimes be ambiguous when multiple transitions occur. For example, in the transition from row 202 to 203 of Study Night 20, there could either be transitions from 1 to 2 and 4 to 3, or from 1 to 3 and 4 to 2. Our approach will always chose the possibility with the lowest initial numeric combination (eg 1 to 2 instead of 1 to 3.)

Here are the kinkajou counts for these two minutes of Night 20.
```{r transition_ambiguity_example}
filter(all_kinkajou_scans, Study_night == 20)[202:203,1:4] #first four columns give timestamp and total counts for each region
```

And here are the transitions infered by our algorithm. Note that the transition from 2 to 2 represents a kinkajou that did not move.

```{r}
transition_arrays[["20"]][,,203]
```

## Drone Image Processing and Flower Counts

The second source of data are orthomosiac images of the balsa crown created by stitching together 100 images taken sequentially by a drone flying over the balsa tree. Because, again, these files are large, the data contained in this repository are geopackages containing WGS 84 locations and tree crown region of each flower in the crown. These data were extracted by first stitching together the drone photos from each flight into an orthmosaic (speak to Andreas about details). Second, Alexander Vining used the software QGIS to align each orthomosiac with Google satellite imagery of the study site and hand-delinieate the three regions of the tree crown. Finally, Nele Stockmeyer created spatial points for each flower in the orthomosaic, noting whether the flower appeared to be upright or fallen over.

The following script extracts the spatial coordinates and regions from the geopackage files and stores them as an spatial features (sf) object, with additional annotation for the date and time of the images from which data were collected. The result looks as such . . .

```{r load_balsa_data, message = FALSE}
region_shapes <- st_read("../DATA/raw/Crown Region Shapes/Crown_Regions.shp") %>% st_set_crs("WGS84") #the shapefiles have already been used to sort flowers. THey are loaded here primarily for the purpose of determining region areas and thus flower densities

  
files = strsplit(dir("../DATA/raw/Flower_geopackages"), split = "[.]") #seperate filenames from extensions for all files in folder
files = files[sapply(files, function(X) X[2] == "gpkg")] #reduce file list only to gpkg files
geopackages <- vector("list", length = length(files))
for(i in seq_along(files)){
  flower_sf <- st_read(paste("../DATA/raw/Flower_geopackages/", files[[i]][1], ".", files[[i]][2], sep = ""), quiet = TRUE)
  flower_sf$Region <- strsplit(files[[i]][1], split = NULL)[[1]] %>% last() %>% as.numeric() + 1 #QGIS labelled regioning grouping outputs at 0 (last element of savefile string); add one to get region labels that match kinkajou data
  flower_sf$Date <- strsplit(files[[i]][1], split = "_")[[1]][2]
  geopackages[[i]] <- flower_sf
}
all_upflowers <- do.call(rbind, geopackages)
all_upflowers$Region <- factor(all_upflowers$Region)

#Drone flights are labelled by a character with date and time of scan. The date needs to be converted to a study day variable and the time put into its own column
all_upflowers <- all_upflowers %>% mutate(Study_night = sapply(Date, function(X) get_study_day_and_time(X, study_start = as.POSIXct("2019-12-14 18:00:00", tz = "America/Panama"))[[1]]),
                                          Time = factor(sapply(Date, function(X) get_study_day_and_time(X, study_start= as.POSIXct("2019-12-14 18:00:00", tz = "America/Panama")) [[2]])))

print(head(all_upflowers))
```

Some of the data in these files come from nights where Nele assed the image quality of the orthomosaic as too poor to accurately count flowers. We remove data from nights marked as such.

```{r flower count cleaning}
all_upflowers <- all_upflowers %>% filter(Time == "AM" | !Study_night %in% c(23, 26, 25, 32)) %>% #remove data from images marked in notes as poor quality photos
  filter(Time == "PM" | !Study_night %in% c(20,21)) #remove data from images marked in notes as poor quality photos
```

Next, we count the flowers in the whole tree on each night and by region. For nights where both drone flights were conducted (AM and PM) and yielded high quality images, we average the two counts.

```{r flower counting}  
flower_counts <- all_upflowers %>% 
  mutate(Study_night = Study_night - (Time == "AM")) %>% #study night is based on date, but we want to match AM recordings to previous PM recording s, so we subtract one from all AM study night values
  group_by(Study_night, Time) %>% 
  summarise(Count = n()) %>% 
  group_by(Study_night) %>% #where there were good photos for both AM and PM, we will use the mean flower count which is achieved by grouping and summariying
  summarise(Count = mean(Count)) %>% 
  transform(Growth = get_growth_index(Count)) %>% #used to visually compare changes in flower count to changes in kinkajou residency without bias
  mutate(Density = Count/(sum(st_area(region_shapes))))

flower_counts_region <- all_upflowers %>% mutate(Study_night = Study_night - (Time == "AM")) %>% #study night is based on date, but we want to match AM recordings to previous PM recordings, so we subtract one from all AM study night values
  group_by(Study_night, Region, Time) %>% 
  summarise(Count = n()) %>% 
  group_by(Study_night, Region) %>% 
  summarise(Count = mean(Count)) %>% 
  group_by(Region) %>% group_modify(~ transform(.x, Growth = get_growth_index(Count))) %>% 
  ungroup()

flower_counts_region <- flower_counts_region %>% mutate(Density = Count/(st_area(region_shapes)[Region])) #divide flower count by area of region to get flower density
```

### Adjusted Flower Counts

For testing our hypotheses, we need to investigate not only how the number of flowers in each region affects kinkajou behavior, but how the relative abundance between regions affects kinkajou behavior. To do this, we determine the average proportion of flowers counted in each region over the full course of the study (eg, Region 1 typically has 0.30 of the total flowers in the tree crown on a given night). We then use this proportion to determine the expected number of flowers in each region for each night, given the total number of flowers. Finally, we subtract this expected flower count from the actual counts in each region to get deviations from the expectation. By using these deviations as predictors of kinkajou behavior, we can tes the effects of increases or decreases in the relative abundance of flowers within regions.

```{r calculate adjusted flower counts}
flower_counts_region <- flower_counts_region %>% mutate(Relative_Density = Density - flower_counts$Density[pmatch(Study_night, flower_counts$Study_night, duplicates.ok = TRUE)]) #match study_nights between regional and full tree flower count data, subtracting the full tree flower density from each regional density for each night

flower_counts_region$Expected_Relative_Density <- NA
for(i in 1:nrow(flower_counts_region)){
  flower_counts_region$Expected_Relative_Density[i] <- mean(filter(flower_counts_region, 
                                                                   Study_night < flower_counts_region$Study_night[i] &
                                                                     Region == flower_counts_region$Region[i])$Relative_Density)
}

#flower_averages are used in next code chunk to calculate adjusted values
flower_averages <- flower_counts_region %>% 
  group_by(Region) %>% 
  summarize(total_flowers = sum(Count)) %>%
  mutate(proportion = total_flowers/sum(total_flowers))
```

## Integrated Data-Structures

Next, we put all of the nightly kinkajou and flower count data together into a single dataframe so they can be easily visualized jointly. First, we integrate flower counts and residence time data
```{r combining_data}
combined_data <- merge(flower_counts, kinkajou_counts, by = "Study_night", all = TRUE)

combined_data_region <- merge(flower_counts_region, kinkajou_counts_region, by = c("Study_night","Region") , all = TRUE) %>%
  mutate(Total_Flowers = combined_data$Count[pmatch(Study_night, combined_data$Study_night, duplicates.ok = TRUE)]) %>%
  mutate(Adjusted_Count = Count - (Total_Flowers * flower_averages$proportion[Region]))
```

### Transition Decisions

Then, we extract from all transitions those that reflect binary "decisions" (i.e. movement from one region to a different region). We annote these decisions with adjusted flower counts in the region moved to and the region avoided, setting up the data-frame to enable analysis of decisions with a binary response. In this response, a 1 indicates that the kinkajou moved to the region with the higher adjusted flower count.

```{r transition decisions}
decisions <- c()
for(i in seq_along(transition_arrays)){
  new_decisions <- get_decision_info(transition_array = transition_arrays[[i]], flower_data = filter(combined_data_region, Study_night == names(transition_arrays[i]))) #see helper functions for get_decision_info
  if(nrow(new_decisions) > 0) new_decisions$Study_night = names(transition_arrays[i])
  decisions = rbind(decisions, new_decisions)
}
decisions <- mutate(decisions, adj_flowers_diff = adj_flowers_to - adj_flowers_avoid)
decisions <- mutate(decisions, Success = adj_flowers_diff > 0)
```


# Data Visualization

With the data prepared, we visualize spatio-temporal patterns of both flowers and kinkajous within the tree-crown as a whole and within regions of the tree crown. Based on our hypotheses, we made some predictions about patterns we expected to see.

First, under Hypothesis A (Kinkajous prefer to forage in regions with greater densities of flowers), we predicted that kinkajous would spend more time in the tree crown, as a whole, when overall flower densities were higher. Under the same hypothesis, we predicted that kinkajous would spend more time in regions of the tree with greater flower density, relative to other regions.

## Kinkajous Residence Times

Below, we visualize the kinkajou counts per region, per night, over the course of the study.

Plotting the data in bar charts gives a good sense of the relative time spent in each region by kinkajous. However, these total counts may be influenced by the duration of observations on that night.

```{r kink_counts_bar}
ggplot(all_kinkajou_scans_long) +
  geom_bar(aes(x = Region, weight = Count, fill = Visibility)) +
  facet_wrap(~Study_night) +
  theme_classic() +
  labs(y = "Kinkajou Minutes")
```

A line plot with study night on the x axis makes clear the periods of time in which observation did not occur. Here, we convert total kinkajou minutes to kinkajou minutes per hour. The data plotted this way highlight temporal trends in overall kinkajou residence in the tree . . .

```{r kinkajou counts line}
ggplot(all_kinkajou_scans_long, aes(x = Study_night, y = Count)) + stat_summary(fun = "get_kinkMinutesPerHour", geom = "line") + stat_summary(fun = "get_kinkMinutesPerHour", geom = "point") +
  theme_classic() +
  labs(title = "Time Spent in Crown", y = "Kinkajou Minutes per Hour")
```

 . . . and kinkajou residence times by region

 
```{r kink counts region}
ggplot(kinkajou_counts_region, aes(x = Study_night, y = Minutes_Per_Hour, color = Region)) + geom_line(stat = "identity") + geom_point(stat = "identity") +
  theme_classic() +
  labs(title = "Time Spent by Kinkajous in Region", y = "Kinkajou Minutes per Hour")
```

## Flower Counts

As with Kinkajou Residence Times, we can plot the total number of flowers over study.

We look first at the counts of all drone flights to check that AM and PM flights are loargely in Agreement
```{r flowers_by_flight}
ggplot(mutate(all_upflowers, Study_night = Study_night - (Time == "AM")), aes(x = Study_night, color = Time)) + geom_line(stat = "count") + geom_point(stat = "count") +
  theme_classic() +
  labs(title = "Upright Flowers Counted")
```

Then we look at the flower counts after averaging AM and PM scans. First, total counts
```{r flower Counts Total}
ggplot(flower_counts, aes(x = Study_night, y = Count)) + 
  geom_line(stat = "identity") + 
  geom_point(stat = "identity") +
  theme_classic() +
  labs(title = "Average Flower Counts")
```

And then the counts by region

```{r flower counts region}
ggplot(flower_counts_region, aes(x = Study_night, y = Count, color = Region)) + geom_line(stat = "identity") + geom_point(stat = "identity") +
  theme_classic() +
  labs(title = "Flower Counts by Region")
```

Because we are interested in how relative changes in flower counts between regions affects kinkajous' movements, we can look at these data another way by adjusting the counts based on expected values. More precisely, this adjusted measure is the observed number of flowers in a region minus the proportion of total flowers observed in that region over the full study times the total number of flowers in the tree that night. This adjusted measure tells us how many more or less flowers are in a region each night than expected based on typical flower distributions in the crown

$$ Adjusted Flower Count_{r,t} = Flower Count_{r,t} - \frac{\sum_{t=1}^{T}Flower Count_{r,t}}{\sum_{r=1}^{R}\sum_{t=1}^{T}Flower Count_{r,t}} * \sum_{r=1}^{R}Flower Count_{r,t} $$

```{r adjusted flower counts region}
ggplot(combined_data_region[!is.na(combined_data_region$Count),], aes(x = Study_night, y = Adjusted_Count, color = Region)) + geom_line(stat = "identity") + geom_point(stat = "identity") +
  theme_classic() +
  labs(title = "Flower Counts by Region")
```

We can see this plot that the adjusted flower count is low in magnitude, meaning the distribution of flowers between regions stays pretty consistent. There is increasing variance in the distribution over time, corresponding with increasing flower counts, but no clear temporal trend in which regions showed greater or lesser concentration of flowers.

## Kinkajou Residence-Flower Interactions

To visualize changes in flower counts and kinkajou residence time together, over the course of the study, we use a growth index which gives the percent change in count or residence time relative to the first respective observation. This ensures the scale of both data types remains the same, and allows unbiased visualization of their relationship.

```{r flowers}
ggplot(flower_counts, aes(x = Study_night, y = Growth)) + 
  geom_line(aes(linetype = "Flower Count"), stat = "identity") +
  geom_point(stat = "identity") +
  geom_line(mapping = aes(linetype = "Residence Time"), data = kinkajou_counts, stat = "identity") +
  geom_point(data = kinkajou_counts, stat = "identity") +
  theme_classic() +
  scale_color_discrete(name = "Flower Count") +
  scale_linetype_manual(values = c("Flower Count" = "solid", "Residence Time" = "dashed")) +
  labs(#title = "Growth in Minutes per Hour Kinkajous spend in a balsa crown (black dotted) \n and balsa flower counts (solid) over study period",
       y = "Growth (%)",
       x = "Study Night",
       title = "Growth in Flower Counts and Kinkajous Residence Time")
```

In the plot above, we see an increase with flower counts over time. Kinkajou residence on the other hand does not appear to have a trend until it drops off toward the end of the study. This runs counter to our prediction drawn from Hypothesis A that kinkajous would spend more time in the three when there were more flowers. However, we do not have data on the other resources available in the kinkajous' environment. Toward the end of our study period, other resources would likely have been coming into season, and thus the balsa tree may have been less attractive relative to other resources in the kinkajous'sd environment, despite the its increasing flower count.
 
```{r analysis_by_region}
#still need to get a legend working on this
ggplot(flower_counts_region, aes(x = Study_night, y = Growth)) + geom_line(color = "green3", stat = "identity", linetype = "solid") + geom_point(stat = "identity", color = "green3") +
  geom_line(data = kinkajou_counts_region, linetype = "dashed") + geom_point(data = kinkajou_counts_region, color = "black") +
  theme_classic() + 
  facet_wrap(~Region, labeller = "label_both") +
  theme(legend.position = "bottom") +
  scale_linetype_manual(name = "", values = c("Flower Count" = "solid", "Kinkajou Minutes Per Hour" = "dashed")) +
  labs(#title = "Growth in Minutes per Hour Kinkajous spend in a balsa crown (black) \n and balsa flower counts (solid) over study period",
       y = "Growth (%)",
       x = "Study Night")
```

Looking at flower counts and residence times by regions, there are not any strongly apparent differences in the interaction between balsa flowers and kinkajous.

## Kinkajous Transitions

Examining only residence times leaves open the possibility that kinkajous simply stay in areas with more flowers because they take more time to forage there. To asses how kinkajous make decisions when moving between regions, we also look at how kinkajous move from region to region.

```{r transition heatmaps}
nightly_transitions <- vector("list", length = length(transition_arrays))
names(nightly_transitions)  <-  names(transition_arrays)
for(i in seq_along(nightly_transitions)) {
  nightly_transitions[[i]] <- apply(transition_arrays[[i]], MARGIN = c(1,2), sum)
}
heatmap(nightly_transitions[[13]], Rowv = NA, Colv = NA, xlab = "Region (to)", ylab = "Region (from)", main = "Transition Heatmap - Study Night 28")
heatmap.2(nightly_transitions[[13]], Rowv = NA, Colv = NA, xlab = "Region (to)", ylab = "Region (from)", main = "Transition Heatmap - Study Night 28", cellnote = nightly_transitions[[13]], trace = "none")
all_transitions <- Reduce("+", nightly_transitions)
heatmap.2(all_transitions, Rowv = NA, Colv = NA, xlab = "Region (to)", ylab = "Region (from)", main = "Transition Heatmap - All Nights", cellnote = all_transitions, trace = "none")
```

The long right tail makes it a little difficult to see differences in the lower end of the transition numbers. We use a log transformation to make transisition rate differences visually clearer in the range of the data that actually represent transition decisions.

```{r}
heatmap.2(log(all_transitions + 1), Rowv = NA, Colv = NA, xlab = "Region (to)", ylab = "Region (from)", main = "Transition Heatmap - All Nights", cellnote = round(log(all_transitions + 1), 2), trace = "none")
```

## Kinkajou Decisions

We look at whether the difference in adjusted counts between regions had any impact on decisions the kinkajous made. Here, a success means the kinkajou went to the region with the greater adjusted flower count. We look at the frequencey of success realtive to the magnitude of difference in adjusted flower count between the regions the kinkajou was choosing between.

```{r decision success plot}
ggplot(na.omit(decisions)) + geom_point(aes(x = abs(adj_flowers_diff), y = Success, color = interaction(To, Avoid))) +
  theme_classic()
```
By appearance, the adjusted flower count does not have an effect on kinkajou decisions

## Summary Statistics

Below, we extract some descriptive statistics for describing some of the patterns in kinkajous residence time and flower counts visualized throughout the plots in this section.

```{r summary statistics}
#means and standard deviation of kinkajou movement
mean_residence <- mean(kinkajou_counts$Minutes_Per_Hour)
var_residence <- sd(kinkajou_counts$Minutes_Per_Hour)
mean_residence_by_region <- group_by(kinkajou_counts_region, Region) %>% dplyr::summarise(Mean = mean(Minutes_Per_Hour), Standard_Deviation =sd(Minutes_Per_Hour))
mean_residence_by_region$Region <- mean_residence_by_region$Region %>% as.character()
mean_residence_by_region <- mean_residence_by_region %>% rbind(c("all", mean_residence, var_residence))
mean_residence_by_region$Units <- "minutes per hour"
mean_residence_by_region

#means and standard deviation of balsa flower
mean_flowers_counts <- mean (flower_counts$Count)
var_flower_counts <- sd(flower_counts$Count)
mean_flower_counts_by_region <- group_by(flower_counts_region, Region) %>% summarise(Mean = mean (Count), Standard_Deviation = sd (Count))
mean_flower_counts_by_region$Region <- mean_flower_counts_by_region$Region %>% as.character()
mean_flower_counts_by_region <- mean_flower_counts_by_region %>% rbind(c("all", mean_flowers_counts, var_flower_counts))
mean_flower_counts_by_region$Units <- "Flowers"
mean_flower_counts_by_region

combined_summary_statistics <- rbind(mean_residence_by_region, mean_flower_counts_by_region)
combined_summary_statistics

paste("mean kinkajou residence in the entire tree, minutes per hour", mean_residence, 
      "standard deviation of kinkajou residence in entire tree, minutes per hour", var_residence,
      "mean flower count in entire tree by day", mean_flowers_counts,
      "standard deviation of mean flower count in entire tree by day", var_flower_counts, sep=" ")
```


# Statistical Analysis

## Flower Count by Night

### Frequentist Linear Model

To begin analyzing the important patterns in the data statistically, we first want to isolate the temporal trends in flower count. We start with a simple linear model, which presumes the number of flowers in the tree steadily increases (or decreases) over the course of the study. For now, we fit the model using both a frequentist and Bayesian model, allowing comparison. We expect these models to yield the same results, but later will shift entirely to a bayesian framework, which will be more robust to our small sample size and the non-independance of data (i.e. it should more accurately determine the uncertainty in the model, and thus is less likely to result in false conclusions)

```{r flower linear regression}
#predicting flower counts based on study night using frequentist methods
flowers_regression_all <- lm(data = select(as.data.frame(flower_counts), !geom), formula = Count ~ Study_night)
summary(flowers_regression_all)
```
We find an intercept of -21.4 in this model, which is clearly biologically implausible (the tree can not have negative flowers), but is reasonable statisitcally given that we did not start collecting data on flowers until day 12, when flowers first began opening. Thus, the model is only fitted to the period when flowers are appearing in the tree, but extends several days before that. Plotting the regression line through the data makes this clear. 

More interestingly, the fixed effect of study night is clearly positive, with an estimated average increase of 4.4 flowers per night of the study.

```{r}
plot(y = predict(flowers_regression_all, newdata = data.frame(Study_night = 0:max(flower_counts$Study_night))), x = 0:max(flower_counts$Study_night), type = "l",
     xlab = "Study Night",
     ylab = "Flower Count",
     main = "Full Tree Flower Count Regression")
points(x = flower_counts$Study_night, y = flower_counts$Count)
```

We can also plot the residuals by night to examine how the model performs over the course of the study. This reveals additional variance toward the end of the study. This unnacounted for structure in the variance is unlikely to strongly affect the assumptions of this linear model, but would be accounted for in a Bayesian approach.

```{r}
plot(x = flower_counts$Study_night, y = flowers_regression_all$residuals,
     xlab = "Study Night",
     ylab = "Residuals",
     main = "Full Tree Flower Count Residuals")
```

The structure of the residuals can be further analyzed by a q-q plot

```{r}
Sflower_all <- sqrt(sum(flowers_regression_all$residuals ^ 2)/(length(flowers_regression_all$residuals) - 2)) #get variance in residuals, for calculating Pearsons residuals
qqnorm(flowers_regression_all$residuals/Sflower_all)
```

### Bayesian Model

We then fit the same model using a Bayesian procedure.

```{r flower bayes regression, eval = FALSE}
#bayesian methods
prior1 <- c(
  prior(normal(0,20), class = Intercept), #prior on intercept has wide variance, given that previous studies indicate that can be dozens of flowers in the tree, but we began collecting data at the begininning of the season. Perhaps the prior mean should be greater than 0)
  prior(normal(0,5), class = b, coef = Study_night), #slope prior is centered at 0 as we don't assume apriori that we will see changes in flower counts over study nights. Variance is less than the intercept, as we expect growth to be only a portion of the typical number of flowers
  prior(cauchy(0,10), class = sigma) #standard prior for variance
)

flowers_regression_all_bayes <- brm(Count ~ Study_night,
                                    data = select(as.data.frame(flower_counts), !geom), 
                                    family = "gaussian",
                                    prior = prior1,
                                    warmup =1000, iter = 2000,
                                    refresh = 0)

save(flowers_regression_all_bayes, file = "../Results/flower_count_MCMCs.Rdata")

summary(flowers_regression_all_bayes)
```
As expected, the results of the bayesian regression closely fit the frequentist approach. For this model, we plot the mean and 89%CI for posterior predictions by study_night.
Question for collaborators: Is it more interesting to plot the Predictive CIs like this, or a sampling of regressions from the posterior

```{r posterior plotting1}
load("../Results/flower_count_MCMCs.Rdata")
#Get predictions from each sample of the posterior for each night in the study
post_predictions <- brms::posterior_predict(flowers_regression_all_bayes, list(Study_night = 1:max(flower_counts$Study_night)))
#determine and plot average predictions with 89% CIs
predictive_CIs <- list(mean_pred = apply(post_predictions, MARGIN = 2, mean),
                       upper = apply(post_predictions, MARGIN = 2, quantile, 0.945),
                       lower = apply(post_predictions, MARGIN = 2, quantile, 0.055))
{
  plot(x = flower_counts$Study_night, y = flower_counts$Count, xlim = c(0, max(flower_counts$Study_night)), ylim = c(min(predictive_CIs[[3]]), max(predictive_CIs[[2]])))
  lines(x = seq_along(predictive_CIs[[1]]), y = predictive_CIs[[1]], type = "l", lty = "dashed")
  lines(x = seq_along(predictive_CIs[[2]]), y = predictive_CIs[[2]], type = "l")
  lines(x = seq_along(predictive_CIs[[3]]), y = predictive_CIs[[3]], type = "l")
}
```

Potential Addition: AR Model of flower counts?

## Kinkajous Residence Times

### Linear Regression (Frequentist)

Next, we look at the pattern of kinkajou residence times in the full tree crown. Following Hypothesis A (Kinkajous prefer to forage in regions with greater densities of flowers) we predicted that kinkajou residence times would increase as a function of flower counts in the tree. This predicted pattern did not appear to hold in the data visualization, but we test the prediction anyway by including both study Night and Flower Count as predictors in a linear model of kinkajous residence times.

```{r residence time regression}
#predicting kinkajou residence time based on study night and adjusted flower count

residence_regression_all <- lm(data = combined_data, formula = Minutes_Per_Hour ~ Study_night + Count)
summary(residence_regression_all)

#res_reg_all<-lm(data = combined_data, formula = Minutes_Per_Hour ~ Study_night)
#summary(res_reg_all)
# plot(x = combined_data$Study_night, y = combined_data$Minutes_Per_Hour)
# lines(x = combined_data$Study_night, y = residence_regression_all$coefficients["(Intercept)"] + residence_regression_all$coefficients["Study_night"] * combined_data$Study_night)
# 
# plot(x = combined_data$Count, y = combined_data$Minutes_Per_Hour)
# lines(x = combined_data$Count, y = residence_regression_all$coefficients["(Intercept)"] + residence_regression_all$coefficients["Count"] * combined_data$Count)
```
As suggested by initial visualization of the data, we so no significant linear effect of study night or flower count on kinkajous residence times in the tree crown. Plotting the residuals of the model reveals no worrisome underlying error structure that would suggest bias or violation of assumptions in the model, but the very small sample size does increase the risk of false conclusions from linear regression

```{r residence regression plot}
Sres_all <- sqrt(sum(residence_regression_all$residuals ^ 2)/(length(residence_regression_all$residuals) - 2))
plot(residence_regression_all$residuals,
     xlab = "Index",
     ylab = "Residuals",
     main = "Full Tree Residence Time Residuals")
```

```{r residence reqression residuals}
qqnorm(residence_regression_all$residuals/Sres_all)
```
### Linear Regression Bayesian

```{r kinkajou bayes regression}
#bayesian methods
prior2 <- c(
  prior(normal(0,20), class = Intercept), #prior on intercept has wide variance, given that previous studies indicate that can be dozens of flowers in the tree, but we began collecting data at the begininning of the season. Perhaps the prior mean should be greater than 0)
  prior(normal(0,5), class = b, coef = Study_night), #slope prior is centered at 0 as we don't assume apriori that we will see changes in flower counts over study nights. Variance is less than the intercept, as we expect growth to be only a portion of the typical number of flowers
  prior(normal(0,5), class = b, coef = Count),
  prior(cauchy(0,10), class = sigma) #standard prior for variance
)

kinks_regression_all_bayes <- brm(Minutes_Per_Hour ~ Study_night + Count,
                                    data = select(as.data.frame(combined_data), !geometry), 
                                    family = "gaussian",
                                    prior = prior2,
                                    warmup =1000, iter = 2000,
                                    refresh = 0)

save(kinks_regression_all_bayes, file = "../Results/residence_time_full_tree_MCMCs.Rdata")
summary(kinks_regression_all_bayes)
```

As expected, the results of the bayesian regression closely fit the frequentist approach. For this model, we visualize the posterior distributions of the co-efficients for Study Night and Flower Count.

```{r posterior plotting2}
load("../Results/residence_time_full_tree_MCMCs.Rdata")
#Get predictions from each sample of the posterior for each night in the study
post_samples <- brms::as_draws_df(kinks_regression_all_bayes)
#determine and plot average predictions with 89% CIs
post_samples %>% 
  pivot_longer(b_Study_night:lp__, names_to = "Coefficient_Type", values_to = "Estimated_Effect") %>%
  filter(Coefficient_Type %in% c("b_Study_night", "b_Count")) %>%
  ggplot() + 
  stat_density_ridges(aes(x = Estimated_Effect, y = Coefficient_Type), scale = 1, quantile_lines = TRUE, quantiles = c(0.055, 0.945)) +
  geom_vline(xintercept = 0, color = "red", linetype = "dashed") +
  theme_classic() +
  labs(title = "Posterior Distribution of Coefficients on Kinkajou Residence Time")
```

Zero is contained with the 89% credible interval of the posterior distributions of either coefficient, thus we do not have sufficient evidence to claim that either the study night or the flower count have an appreciable effect on the nightly residence times of kinkajous in the balsa crown.

## Analysis of Crown Regions

Under Hypothesis A (Kinkajous prefer to forage in regions with greater densities of flowers), we predict that the more flowers are in a region of the tree crown, relative to the other regions, the more time kinkajous will spend in that region for the night. Because this prediction concerns the correlations between regional flowers, we begin by looking at the correlation matrix for flowers counts and kinkajou residence times in each region

```{r residence correlations by region}
correlations <- combined_data_region %>% 
  select(Count, Region, Minutes_Per_Hour, Total_Flowers, Study_night) %>% 
  pivot_wider(names_from = Region, values_from = c(Count, Minutes_Per_Hour)) %>% 
  select(!Study_night) %>%
  cor(use = "complete.obs")

corrplot(correlations, method = "color")
```

This correlogram reveals a negative relationship between flower counts in a region and residence time in that region. However, this likely reflects the pattern of residence time and flower counts in the whole tree. We are interested in how the density of flowers relative to other regions affects residence times. For this, we look at the correlation between adjusted flower count and residence time.

```{r proportion correlations}
correlations_proportion <- combined_data_region %>% 
  mutate(Count_proportion = Count/Total_Flowers) %>%
  select(Count_proportion, Region, Minutes_Per_Hour, Total_Flowers, Study_night) %>% 
  pivot_wider(names_from = Region, values_from = c(Count_proportion, Minutes_Per_Hour)) %>% 
  select(!Study_night) %>%
  cor(use = "complete.obs")
  
corrplot(correlations_proportion, method = "color")
```

This correllelation between flower count and residence time is near zero in region 1, in region two it is negative and in region 3 it is positive.

### bayesian methods

We use a model to measure the impact of both regional flower counts and adjusted flower counts on kinkajou residence time. In addition to these two predictor variables, this model includes a fixed effect of each region on residence time. As of right now, this model uses default priors from get_prior, which are probably too wide.
```{r regional analysis bayes}
prior3 <- get_prior(Minutes_Per_Hour ~ Adjusted_Count + Region + Total_Flowers,
                                            data = combined_data_region, 
                                            family = "gaussian")

residence_by_region_regression_model <- brm(Minutes_Per_Hour ~ Adjusted_Count + Region + Total_Flowers,
                                            data = combined_data_region, 
                                            family = "gaussian",
                                            prior = prior3,
                                            warmup =1000, iter = 2000,
                                            refresh = 0)
save(residence_by_region_regression_model, file = "../Results/residence_by_region_MCMCs.Rdata")
summary(residence_by_region_regression_model)
```

By plotting the posterior distribution of parameter coeficcients, we can see the neither the total number of flowers nor the adjusted counts had a clear impact on kinkajous residence times.

```{r posterior plotting3}
load("../Results/residence_by_region_MCMCs.Rdata")
#Get predictions from each sample of the posterior for each night in the study
post_samples <- brms::as_draws_df(residence_by_region_regression_model)
names(post_samples)[c(1,3,4)] <- c("Region1", "Region2", "Region3") #Rename from Intercept for clarity
post_samples$Region2 <- post_samples$Region2 + post_samples$Region1 #convert estimates of Region 2 coefficient to intercept estimate for region 2
post_samples$Region3 <- post_samples$Region3 + post_samples$Region1
#determine and plot average predictions with 89% CIs
post_samples %>% 
  pivot_longer(Region1:lp__, names_to = "Coefficient_Type", values_to = "Estimated_Effect") %>%
  filter(Coefficient_Type %in% c("Region1", "Region2", "Region3", "b_Total_Flowers", "b_Adjusted_Count")) %>%
  ggplot() + 
  stat_density_ridges(aes(x = Estimated_Effect, y = Coefficient_Type), scale = 1, quantile_lines = TRUE, quantiles = c(0.055, 0.945)) + #the quantile lines on total flowers look wrong . . .
  geom_vline(xintercept = 0, color = "red", linetype = "dashed") +
  theme_classic() +
  xlim(-10, 25) +
  labs(title = "Posterior Distribution of Coefficients on Kinkajou-Minutes",
       x = "Estimate Effect",
       y = "Coefficient")
```

