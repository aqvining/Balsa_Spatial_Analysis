---
title: "Spatial-Temporal Distribution of Kinkajous in a Balsa Tree"
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
---

# Overview

The analysis in this document seeks to answer the question "What factors influence the movements of kinkajous within the crown of a balsa tree?". We start with a few hypotheses:

A. Kinkajous prefer to forage in regions with greater densities of flowers
B. Kinkajous assess the density of flowers within a region through perception and/or sampling effort.
C. Kinkajous predict which regions will have more flowers using information obtained from foraging on previous nights
D. Kinkajous will avoid direct foraging competition with other kinkajous
E. Kinkajous remember where they have been and avoid foraging in recently depleted regions

To test these hypotheses, we collected data on the location of flowers within a balsa tree crown each night, and the locations of kinkajous within that crown every minute for four-hour periods. In order to conduct a spatial analysis, we divided the tree crown into three regions. As best as possible, these regions divided the crown such that all the offshoots of one or more primary branches were contained within a single region. We then tested how the spatio-temporal distribution of flowers within these regions related to the residence times of kinkajous within each region, and to the transitions of kinkajous between regions.

In this document, we 1) prepare and clean the data, 2) Develop predictions about the relationships between flower counts, kinkajou presence, and kinajous movements within and between regions, 3) visualize these relationships, and 4) develop and run statistical models to test predictions that appear to be supported by patterns in the data.

# Data Setup

```{r, setup, include=FALSE}
library(stringr)
library(readr)
library(tidyr)
library(lubridate)
library(sf)
library(dplyr)
library(ggplot2)
library(ggridges)
library(scales)
library(nlme)
library(brms)
```

```{r helper_functions, include=FALSE}
get_study_day_and_time <- function(Datetime_string, study_start) {
  #study start must include the approximate start time of evening observations if overnight follows are to be binned into the correct study day
  datetime_vector <- strsplit(Datetime_string, split = "")[[1]]
  date1 <- paste(paste(datetime_vector[1:6], collapse = ""), 
                "20", 
                paste(datetime_vector[7:8], collapse = ""), sep = "") %>% as.POSIXct(format = "%d-%m-%Y", tz = "America/Panama")
  time1 = paste(datetime_vector[9:10], collapse = "")
  study_day = difftime(date1, study_start, units = "days") %>% floor()
  return(list(study_day, time1))
}

get_kinkMinutesPerHour <- function(count_data, categories = 6) {
  #default value for categories assumes count data has 6 rows per observational minute, representing 3 Regions x 2 states (hidden or visible)
  minutes_per_hour = (sum(count_data)/(length(count_data)/categories)) * 60
  return(minutes_per_hour)
}

get_growth_index <- function(time_series) {
  removed = 0
  while(time_series[1] == 0) {
    time_series <- time_series[-1]
    warning("initial observation removed due to value of 0")
    removed = removed + 1
  }
  growth_index <- ((time_series-time_series[1])/time_series[1]) * 100
  return(c(rep(NA, times = removed), growth_index))
}
```

The data used for this analysis come from two sources: side-angle thermal video recordings of the balsa tree and top-down photographs of the tree captured by drone.

## Thermal Video Data Processing and Kinkajou Counts

The thermal videos are of the full balsa tree crown, recorded from the side. Most recordings were four hours, except where interrupted by rain. Recordings had outlines of the regions superimposed by Alexander Vining (using the software ProCreate), who previously diagrammed the full tree and observed kinkajous in the tree during all recordings. Because these files are large, they are not included in this repository. Instead, the data included here are the number of kinkajous in each region for each minute of a recording. These data are contained in the folder Kinkajou_Scans_Nele. The counts were determined by Nele Stockmeyer, who watched all of the thermal videos and scanned the tree each minute. Kinkajou counts are further annotated by the number of counted kinkajous that were not visible during the given scan, but their presence was inferred from other scans ("hidden").  Further details on the data collection process are contained in the manuscript ". . ."

In addition to the kinkajou counts, which are annotated by video-minutes, the file video_file_timestamp_metdata_cam1 contains the start and end timestamps of each video. These allow conversion of video-minutes to timestamps. 

We begin data preparation by determining the file names for all of the kinkajou count data, for which there is one .csv file per night of recording. We also parse the metadata file to store the start timestamps in a vector. We then read in each kinkajou count data file, convert the video-minutes to timestamps, and collect all of the data into a single dataframe.

```{r data_load, message = FALSE}
file_names <- dir("../DATA/raw/Kinkajou_Scans_Nele", pattern = ".csv")

video_metadata_location <- "../DATA/raw/Video_metadata/video_file_timestamp_metadata_cam1.txt"
video_metadata <- readChar(con = video_metadata_location, nchars = file.info(video_metadata_location)$size)
video_metadata <- str_split(video_metadata, pattern = "Folder: ")[[1]][-1] #break all metadata into strings for each observation period (and remove preceding empty character)
video_metadata <- str_split(video_metadata, pattern =  "start = ") #find the start time of all files
start_timestamps <- sapply(video_metadata, function(X) str_split(X[2], pattern = "\r")[[1]][1]) #extract start time of first file and remove all extra data
start_timestamps <- as.POSIXct(start_timestamps, format = "%Y-%m-%d_%H-%M-%S", tz = "GMT")
start_timestamps <- with_tz(start_timestamps, "America/Panama")


all_kinkajou_scans <-  c()
Jan_22_check = FALSE #used later to parse two video files that started on the same day (one AM one PM)

for(file_name in file_names) {
  scan_data <- read_csv(paste("../DATA/raw/Kinkajou_Scans_Nele/", file_name, sep = ""), skip = 1, progress = FALSE)
  colnames(scan_data) <- c("timestamp", "Region1_total", "Region1_hidden", "Region2_total", "Region2_hidden", "Region3_total", "Region3_hidden", "Kinkajou_Notes", "Video_Notes", "Extraneous")
  scan_data <- scan_data[complete.cases(scan_data$timestamp),] %>% select(! Extraneous)
  start_date <- str_split(file_name ,pattern = "_Cam")[[1]][1] #str_split returns a list of string components. We want the first (and only) element of this list - then the first string element in this list gives the date
  start_date <- as.POSIXct(paste("20", start_date, sep = ""), format = "%Y_%m_%d") #date needs all 4 digits
  start_timestamp <- start_timestamps[which(date(start_timestamps) == start_date)]
  #Two video files started on Jan 22nd, one AM and one PM. Because this is the ONLY date where this occurred, I implemented a quick and dirty check to parse the AM file first and the PM file second, below
  if (length(start_timestamp) > 1)
      if (! Jan_22_check) {
        start_timestamp <- start_timestamp[1]
        Jan_22_check <-  TRUE
      } else start_timestamp <- start_timestamp[2]
  #end Jan 22 case
  scan_data$timestamp <- start_timestamp + period_to_seconds(hms(scan_data$timestamp))
  scan_data$Study_night <- round(as.numeric(start_timestamp - start_timestamps[1], units = "days"), digits = 0)
  all_kinkajou_scans <- rbind(all_kinkajou_scans, scan_data)
}

head(all_kinkajou_scans)
```

We continue preparing the kinkajous count data by converting the data from a) total kinkajous per region and b) hidden kinkajous per region to a) visible kinkajous per region and b) hidden kinkajous per region. This makes analysis using either type of count separately easier.

```{r data_prep}
#convert empty count cells (NAs) to 0
count_data <- all_kinkajou_scans[,2:7] # columns 2 through 7 are the count data columns, we want NAs in the notes columns, but 0s in the count data
count_data[is.na(count_data)] <- 0
all_kinkajou_scans[,2:7] <- count_data

#The data as read contain the TOTAL number of kinkajous and the number of those total that are hidden. As suggested by the new names given to the columns in this data structure, we want the count of visible and hidden kinkajous, not the total. The adjustment is made below
all_kinkajou_scans <- mutate(all_kinkajou_scans, Region1_visible = Region1_total - Region1_hidden, Region2_visible = Region2_total - Region2_hidden, Region3_visible = Region3_total - Region3_hidden) %>% 
  select(timestamp, Region1_total, Region2_total, Region3_total, Region1_visible, Region1_hidden, Region2_visible, Region2_hidden, Region3_visible, Region3_hidden, Study_night, Kinkajou_Notes, Video_Notes)

#pivot dataframe to long format for easy usage in ggplot
all_kinkajou_scans_long <- pivot_longer(all_kinkajou_scans,
                                   cols = Region1_visible:Region3_hidden,
                                   names_to = c("Region", "Visibility"),
                                   names_sep = "_",
                                   values_to = "Count")

all_kinkajou_scans_long$Region <- sapply(all_kinkajou_scans_long$Region, switch, "Region1" = "1", "Region2" = "2", "Region3" = "3") %>% factor()

write.csv(all_kinkajou_scans_long, "../DATA/processed/all_kinkajou_scans.csv")
```

With a quick operation, we also create a table of the total kinkajous-minutes spent in the whole crown and in each region on each night (where two kinkajous counted in the same regions during a scan consititutes two kinkajou-minutes
)
```{r nightly_kink_counts}
kinkajou_counts <- all_kinkajou_scans_long %>% group_by(Study_night) %>% summarise(Minutes_Per_Hour = get_kinkMinutesPerHour(Count)) %>% transform(Growth = get_growth_index(Minutes_Per_Hour))

kinkajou_counts_region <- all_kinkajou_scans_long %>% group_by(Study_night, Region) %>% summarise(Minutes_Per_Hour = get_kinkMinutesPerHour(Count, categories = 2)) %>% group_by(Region) %>% group_modify(~ transform(.x, Growth = get_growth_index(Minutes_Per_Hour)))
```

In addition to the counts of kinkajous in each region, we are interested in how kinkajous transitions between region. Thus, we use the count data to create a transition matrix for each scan, where the number in each cell denotes how many kinkajous moved from the region denoted by the row to the region denoted by the column. These transitions matrices are collated into an array for each study night, where the third dimension is the scan (video-minute). The arrays for each night are stored in a list.

```{r Get_transitions}

get_transitions <- function(count_data){
  #input: a dataframe with columns "Region1_total", "Region2_total", "Region3_total" and (optionally) "timestamp".
  #output: an array giving the number of transitions from one region (first dimension) to another (second dimension) for each minute (row) of the input data (third dimension)
  transitions <- array(data = 0, dim = c(4,4,nrow(count_data)))
  if("timestamp" %in% colnames(count_data)) arrange(count_data, timestamp)
  count_data <- select(count_data, Region1_total, Region2_total, Region3_total)
  for(i in 2:nrow(count_data)){
    #to calculate the transition matrix, we treat the counts in the previous timestep as the row totals of the transition matrix
    row_totals <- c(unlist(count_data[i-1,]),
                    max(sum(count_data[i,]) - sum(count_data[i -1,]), 0)) #create a fourth row total for kinkajous entering the tree by differencing the total kinkajou counts of the current timestep and the previous timestep, counting only positive differences.
    #we then treat the counts in the current timestep as the column totals in the transition matrix
    col_totals <- c(unlist(count_data[i,]),
                    max(sum(count_data[i-1,]) - sum(count_data[i,]), 0)) #create a fourth column total for kinkajous leaving the tree
    for(j in seq_along(row_totals)){
      for(k in seq_along(col_totals)){
        m <- min(row_totals[j], col_totals[k]) #m is the maximum number of transitions that can contribute to both the relevant row total and column total
        transitions[j,k,i] <- m
        row_totals[j] <- row_totals[j] - m #subtract the number of transitions that have been added from the corresponding row total
        col_totals[k] <- col_totals[k] - m #subtract the number of transitions that have been added from the corresponding column total
      }
    }
  }
  return(transitions)
}

transition_arrays <- all_kinkajou_scans %>% group_by(Study_night) %>% group_map(~get_transitions(.x))
names(transition_arrays) <- as.character(unique(all_kinkajou_scans$Study_night))
```

Because we only have counts, this method can sometimes be ambiguous when multiple transitions occur. For example, in the transition from row 202 to 203 of Study Night 20, there could either be transitions from 1 to 2 and 4 to 3, or from 1 to 3 and 4 to 2. Our approach will always chose the possibility with the lowest initial numeric combination (eg 1 to 2 instead of 1 to 3.)

Here are the kinkajou counts for these two minutes of Night 20.
```{r transition_ambiguity_example}
filter(all_kinkajou_scans, Study_night == 20)[202:203,1:4] #first four columns give timestamp and total counts for each region
```

And here are the transitions infered by our algorithm. Note that the transition from 2 to 2 represents a kinkajous that did not move.

```{r}
transition_arrays[["20"]][,,203]
```


## Drone Image Processing and Flower Counts

The second source of data are orthomosiac images of the balsa crown created by stitching together 100 images taken sequentially by a drone flying over the balsa tree. Because, again, these files are large, the data contained in this repository are geopackages containing WGS 84 locations and tree crown region of each flower in the crown. These data were extracted by first stitching together the drone photos from each flight into an orthmosaic (speak to Andreas about details). Second, Alexander Vining used the software QGIS to align each orthomosiac with Google satellite imagery of the study site and hand-delinieate the three regions of the tree crown. Finally, Nele Stockmeyer created spatial points for each flower in the orthomosaic, noting whether the flower appeared to upright or fallen over.

The following script extracts the spatial coordinates and regions from the geopackage files and stores them as an spatial features (sf) object, with additional annotation for the date and time of the images from which data were collected. The result looks as such . . .

```{r load_balsa_data, message = FALSE}
files = strsplit(dir("../DATA/raw/Flower_geopackages"), split = "[.]") #seperate filenames from extensions for all files in folder
files = files[sapply(files, function(X) X[2] == "gpkg")] #reduce file list only to gpkg files
geopackages <- vector("list", length = length(files))
for(i in seq_along(files)){
  flower_sf <- st_read(paste("../DATA/raw/Flower_geopackages/", files[[i]][1], ".", files[[i]][2], sep = ""), quiet = TRUE)
  flower_sf$Region <- strsplit(files[[i]][1], split = NULL)[[1]] %>% last() %>% as.numeric() + 1 #QGIS labelled regioning grouping outputs at 0 (last element of savefile string); add one to get region labels that match kinkajou data
  flower_sf$Date <- strsplit(files[[i]][1], split = "_")[[1]][2]
  geopackages[[i]] <- flower_sf
}
all_upflowers <- do.call(rbind, geopackages)
all_upflowers$Region <- factor(all_upflowers$Region)

#Drone flights are labelled by a character with date and time of scan. The date needs to be converted to a study day variable and the time put into its own column
all_upflowers <- all_upflowers %>% mutate(Study_night = sapply(Date, function(X) get_study_day_and_time(X, study_start = as.POSIXct("2019-12-14 18:00:00", tz = "America/Panama"))[[1]]),
                                          Time = factor(sapply(Date, function(X) get_study_day_and_time(X, study_start= as.POSIXct("2019-12-14 18:00:00", tz = "America/Panama")) [[2]])))

print(head(all_upflowers))
```

Some of the data in these files come from nights where Nele assed the image quality of the orthomosaic as too poor to accurately count flowers. We remove data from nights marked as such.

```{r flower count cleaning}
all_upflowers <- all_upflowers %>% filter(Time == "AM" | !Study_night %in% c(23, 26, 25, 32)) %>% #remove data from images marked in notes as poor quality photos
  filter(Time == "PM" | !Study_night %in% c(20,21)) #remove data from images marked in notes as poor quality photos
```

Next, we count the flowers in the whole tree on each night and by region. For nights where both drone flights were conducted (AM and PM) and yielded high quality images, we average the two counts.

```{r flower counting}  
flower_counts <- all_upflowers %>% 
  group_by(Study_night, Time) %>% summarise(Count = n()) %>% 
  mutate(Study_night = Study_night - (Time == "AM")) %>% #study night is based on date, but we want to match AM recordings to previous PM recordins, so we subtract one from all AM study night values
  group_by(Study_night) %>% #where there were good photos for both AM and PM, we will use the mean flower count which is achieved by grouping and summariying
  summarise(Count = mean(Count)) %>% 
  transform(Growth = get_growth_index(Count)) #used to visually compare changes in flower count to changes in kinkajou residency without bias

flower_counts_region <- all_upflowers %>% mutate(Study_night = Study_night - (Time == "AM")) %>% #study night is based on date, but we want to match AM recordings to previous PM recordins, so we subtract one from all AM study night values
  group_by(Study_night, Region) %>% 
  summarise(Count = n()) %>% 
  group_by(Study_night, Region) %>% 
  mutate(Count = mean(Count)) %>% 
  group_by(Region) %>% group_modify(~ transform(.x, Growth = get_growth_index(Count))) %>% 
  ungroup()
```


Lastly, we put all of the nightly kinkajou and flower count data together into a single dataframe so they can be easily visualized jointly.
```{r combining_data}
combined_data <- merge(flower_counts, kinkajou_counts, by = "Study_night", all = TRUE)
```

# Data Visualization

With the data prepared, we visualize spatio-temporal patterns of both flowers and kinkajous within the tree-crown as a whole and within regions of the tree crown. Based on our hypotheses, we made some predictions about patterns we expected to see.

First, under Hypothesis A (Kinkajous prefer to forage in regions with greater densities of flowers), we predicted that kinkajous would spend more time in the tree crown, as a whole, when overall flower densities were higher. Under the same hypothesis, we predicted that kinkajous would spend more time in regions of the tree with greater flower density, relative to other regions.

## Kinkajous Residence Times

Below, we visualize the kinkajou counts per region, per night, over the course of the study.

Plotting the data in bar charts gives a good sense of the relative time spent in each region by kinkajous. However, these total counts may be influenced by the duration of observations on that night.

```{r kink_counts_bar}
ggplot(all_kinkajou_scans_long) +
  geom_bar(aes(x = Region, weight = Count, fill = Visibility)) +
  facet_wrap(~Study_night) +
  theme_classic() +
  labs(y = "Kinkajou Minutes")
```
A line plot with study night on the x axis makes clear the periods of time in which observation did not occur. Here, we convert total kinkajou minutes to kinkajou minutes per hour. The data plotted this way highlight temporal trends in overall kinkajou residence in the tree . . .

```{r kinkajou counts line}
ggplot(all_kinkajou_scans_long, aes(x = Study_night, y = Count)) + stat_summary(fun = "get_kinkMinutesPerHour", geom = "line") + stat_summary(fun = "get_kinkMinutesPerHour", geom = "point") +
  theme_classic() +
  labs(title = "Time Spent in Crown", y = "Kinkajou Minutes per Hour")
```
 . . . and kinkajou residence times by region

 
```{r kink counts region}
ggplot(kinkajou_counts_region, aes(x = Study_night, y = Minutes_Per_Hour, color = Region)) + geom_line(stat = "identity") + geom_point(stat = "identity") +
  theme_classic() +
  labs(title = "Time Spent by Kinkajous in Region", y = "Kinkajou Minutes per Hour")
```

## Flower Counts

As with Kinkajou Residence Times, we can plot the total number of flowers over study.

We look first at the counts of all drone flights to check that AM and PM flights are loargely in Agreement
```{r flowers_by_flight}
ggplot(mutate(all_upflowers, Study_night = Study_night - (Time == "AM")), aes(x = Study_night, color = Time)) + geom_line(stat = "count") + geom_point(stat = "count") +
  theme_classic() +
  labs(title = "Upright Flowers Counted")
```

Then we look at the flower counts after averaging AM and PM scans. First, total counts
```{r flower Counts Total}
ggplot(flower_counts, aes(x = Study_night, y = Count)) + 
  geom_line(stat = "identity") + 
  geom_point(stat = "identity") +
  theme_classic() +
  labs(title = "Flower Counts by Region")
```
And then the counts by region

```{r flower counts region}
ggplot(flower_counts_region, aes(x = Study_night, y = Count, color = Region)) + geom_line(stat = "identity") + geom_point(stat = "identity") +
  theme_classic() +
  labs(title = "Flower Counts by Region")
```

## Kinkajou Residence-Flower Interactions

To visualize changes in flower counts and kinkajou residence time together, over the course of the study, we use a growth index which gives the percent change in count or residence time relative to the first respective observation. This ensures the scale of both data types remains the same, and allows unbiased visualization of their relationship.

```{r flowers}
ggplot(flower_counts, aes(x = Study_night, y = Growth)) + 
  geom_line(aes(linetype = "Flower Count"), stat = "identity") +
  geom_point(stat = "identity") +
  geom_line(mapping = aes(linetype = "Residence Time"), data = kinkajou_counts, stat = "identity") +
  geom_point(data = kinkajou_counts, stat = "identity") +
  theme_classic() +
  scale_color_discrete(name = "Flower Count") +
  scale_linetype_manual(values = c("Flower Count" = "solid", "Residence Time" = "dashed")) +
  labs(#title = "Growth in Minutes per Hour Kinkajous spend in a balsa crown (black dotted) \n and balsa flower counts (solid) over study period",
       y = "Growth (%)",
       x = "Study Night")
```
 In the plot above, we see an increase with flower counts over time. Kinkajou residence on the other hand does not appear to have a trend until it drops off toward the end of the study. This runs counter to our prediction drawn from Hypothesis A that kinkajous would spend more time in the three when there were more flowers. However, we do not have data on the other resources available in the kinkajous' environment. Toward the end of our study period, other resources would likely have been coming into season, and thus the balsa tree may have been less attractive relative to other resources in the kinkajous'sd environment, despite the its increasing flower count.
 
```{r analysis_by_region}
#still need to get a legend working on this
ggplot(flower_counts_region, aes(x = Study_night, y = Growth)) + geom_line(color = "green3", stat = "identity", linetype = "solid") + geom_point(stat = "identity", color = "green3") +
  geom_line(data = kinkajou_counts_region, linetype = "dashed") + geom_point(data = kinkajou_counts_region, color = "black") +
  theme_classic() + 
  facet_wrap(~Region, labeller = "label_both") +
  theme(legend.position = "bottom") +
  scale_linetype_manual(name = "", values = c("Flower Count" = "solid", "Kinkajou Minutes Per Hour" = "dashed")) +
  labs(#title = "Growth in Minutes per Hour Kinkajous spend in a balsa crown (black) \n and balsa flower counts (solid) over study period",
       y = "Growth (%)",
       x = "Study Night")
```
Looking at flower counts and residence times by regions, there are not any strongly apparent differences in the interaction between balsa flowers and kinkajous.

Below, we extract some descriptive statistics for describing some of the patterns in kinkajous residence time and flower counts visualized throughout the plots in this section.

```{r summary statistics}
#means and standard deviation of kinkajou movement
mean_residence <- mean(kinkajou_counts$Minutes_Per_Hour)
var_residence <- sd(kinkajou_counts$Minutes_Per_Hour)
mean_residence_by_region <- group_by(kinkajou_counts_region, Region) %>% dplyr::summarise(Mean = mean(Minutes_Per_Hour), Standard_Deviation =sd(Minutes_Per_Hour))
mean_residence_by_region$Region <- mean_residence_by_region$Region %>% as.character()
mean_residence_by_region <- mean_residence_by_region %>% rbind(c("all", mean_residence, var_residence))
mean_residence_by_region$Units <- "minutes per hour"
mean_residence_by_region

#means and standard deviation of balsa flower
mean_flowers_counts <- mean (flower_counts$Count)
var_flower_counts <- sd(flower_counts$Count)
mean_flower_counts_by_region <- group_by(flower_counts_region, Region) %>% summarise(Mean = mean (Count), Standard_Deviation = sd (Count))
mean_flower_counts_by_region$Region <- mean_flower_counts_by_region$Region %>% as.character()
mean_flower_counts_by_region <- mean_flower_counts_by_region %>% rbind(c("all", mean_flowers_counts, var_flower_counts))
mean_flower_counts_by_region$Units <- "Flowers"
mean_flower_counts_by_region

combined_summary_statistics <- rbind(mean_residence_by_region, mean_flower_counts_by_region)
combined_summary_statistics

paste("mean kinkajou residence in the entire tree, minutes per hour", mean_residence, 
      "standard deviation of kinkajou residence in entire tree, minutes per hour", var_residence,
      "mean flower count in entire tree by day", mean_flowers_counts,
      "standard deviation of mean flower count in entire tree by day", var_flower_counts, sep=" ")
```

# Statistical Analysis

## Flower Count by Night

### Frequentist Linear Model

To begin analyzing the important patterns in the data statistically, we first want to isolate the temporal trends in flower count. We start with a simple linear model, which presumes the number of flowers in the tree steadily increases (or decreases) over the course of the study. For now, we fit the model using both a frequentist and Bayesian model, allowing comparison. We expect these models to yield the same results, but later will shift entirely to a bayesian framework, which will be more robust to our small sample size and the non-independance of data (i.e. it should more accurately determine the uncertainty in the model, and thus is less likely to result in false conclusions)

```{r flower linear regression}
#predicting flower counts based on study night using frequentist methods
flowers_regression_all <- lm(data = select(as.data.frame(flower_counts), !geom), formula = Count ~ Study_night)
summary(flowers_regression_all)
```
We find an intercept of -21.4 in this model, which is clearly biologically implausible (the tree can not have negative flowers), but is reasonable statisitcally given that we did not start collecting data on flowers until day 12, when flowers first began opening. Thus, the model is only fitted to the period when flowers are appearing in the tree, but extends several days before that. Plotting the regression line through the data makes this clear. 

More interestingly, the fixed effect of study night is clearly positive, with an estimated average increase of 4.4 flowers per night of the study.

```{r}
plot(y = predict(flowers_regression_all, newdata = data.frame(Study_night = 0:max(flower_counts$Study_night))), x = 0:max(flower_counts$Study_night), type = "l",
     xlab = "Study Night",
     ylab = "Flower Count",
     main = "Full Tree Flower Count Regression")
points(x = flower_counts$Study_night, y = flower_counts$Count)
```

We can also plot the residuals by night to examine how the model performs over the course of the study. This reveals additional variance toward the end of the study. This unnacounted for structure in the variance is unlikely to strongly affect the assumptions of this linear model, but would be accounted for in a Bayesian approach.

```{r}
plot(x = flower_counts$Study_night, y = flowers_regression_all$residuals,
     xlab = "Study Night",
     ylab = "Residuals",
     main = "Full Tree Flower Count Residuals")
```

The structure of the residuals can be further analyzed by a q-q plot

```{r}
Sflower_all <- sqrt(sum(flowers_regression_all$residuals ^ 2)/(length(flowers_regression_all$residuals) - 2)) #get variance in residuals, for calculating Pearsons residuals
qqnorm(flowers_regression_all$residuals/Sflower_all)
```

### Bayesian Model

We then fit the same model using a Bayesian procedure.

```{r flower bayes regression}
#bayesian methods
prior1 <- c(
  prior(normal(0,20), class = Intercept), #prior on intercept has wide variance, given that previous studies indicate that can be dozens of flowers in the tree, but we began collecting data at the begininning of the season. Perhaps the prior mean should be greater than 0)
  prior(normal(0,5), class = b, coef = Study_night), #slope prior is centered at 0 as we don't assume apriori that we will see changes in flower counts over study nights. Variance is less than the intercept, as we expect growth to be only a portion of the typical number of flowers
  prior(cauchy(0,10), class = sigma) #standard prior for variance
)

flowers_regression_all_bayes <- brm(Count ~ Study_night,
                                    data = select(as.data.frame(flower_counts), !geom), 
                                    family = "gaussian",
                                    prior = prior1,
                                    warmup =1000, iter = 2000,
                                    refresh = 0)

summary(flowers_regression_all_bayes)
```
As expected, the results of the bayesian regression closely fit the frequentist approach. For this model, we plot the mean and 89%CI for posterior predictions by study_night.
Queation for collaborators: Is it more interesting to plot the Predictive CIs like this, or a sampling of regressions from the posterior

```{r posterior plotting1}
#Get predictions from each sample of the posterior for each night in the study
post_predictions <- brms::posterior_predict(flowers_regression_all_bayes, list(Study_night = 1:max(flower_counts$Study_night)))
#determine and plot average predictions with 89% CIs
predictive_CIs <- list(mean_pred = apply(post_predictions, MARGIN = 2, mean),
                       upper = apply(post_predictions, MARGIN = 2, quantile, 0.945),
                       lower = apply(post_predictions, MARGIN = 2, quantile, 0.055))
{
  plot(x = flower_counts$Study_night, y = flower_counts$Count, xlim = c(0, max(flower_counts$Study_night)), ylim = c(min(predictive_CIs[[3]]), max(predictive_CIs[[2]])))
  lines(x = seq_along(predictive_CIs[[1]]), y = predictive_CIs[[1]], type = "l", lty = "dashed")
  lines(x = seq_along(predictive_CIs[[2]]), y = predictive_CIs[[2]], type = "l")
  lines(x = seq_along(predictive_CIs[[3]]), y = predictive_CIs[[3]], type = "l")
}
```

Potential Addition: AR Model of flower counts?

## Kinkajous Residence Times

### Linear Regression (Frequentist)

Next, we look at the pattern of kinkajou residence times in the full tree crown. Following Hypothesis A (Kinkajous prefer to forage in regions with greater densities of flowers) we predicted that kinkajou residence times would increase as a function of flower counts in the tree. This predicted pattern did not appear to hold in the data visualization, but we test the prediction anyway by including both study Night and Flower Count as predictors in a linear model of kinkajous residence times.

```{r residence time regression}
#predicting kinkajou residence time based on study night and flower count

residence_regression_all <- lm(data = combined_data, formula = Minutes_Per_Hour ~ Study_night + Count)
summary(residence_regression_all)

#res_reg_all<-lm(data = combined_data, formula = Minutes_Per_Hour ~ Study_night)
#summary(res_reg_all)
# plot(x = combined_data$Study_night, y = combined_data$Minutes_Per_Hour)
# lines(x = combined_data$Study_night, y = residence_regression_all$coefficients["(Intercept)"] + residence_regression_all$coefficients["Study_night"] * combined_data$Study_night)
# 
# plot(x = combined_data$Count, y = combined_data$Minutes_Per_Hour)
# lines(x = combined_data$Count, y = residence_regression_all$coefficients["(Intercept)"] + residence_regression_all$coefficients["Count"] * combined_data$Count)
```
As suggested by initial visualization of the data, we so no significant linear effect of study night or flower count on kinkajous residence times in the tree crown. Plotting the residuals of the model reveals no worrisome underlying error structure that would suggest bias or violation of assumptions in the model, but the very small sample size does increase the risk of false conclusions from linear regression

```{r residence regression plot}
Sres_all <- sqrt(sum(residence_regression_all$residuals ^ 2)/(length(residence_regression_all$residuals) - 2))
plot(residence_regression_all$residuals,
     xlab = "Index",
     ylab = "Residuals",
     main = "Full Tree Residence Time Residuals")
```

```{r residence reqression residuals}
qqnorm(residence_regression_all$residuals/Sres_all)
```
### Linear Regression Bayesian

```{r kinkajou bayes regression}
#bayesian methods
prior2 <- c(
  prior(normal(0,20), class = Intercept), #prior on intercept has wide variance, given that previous studies indicate that can be dozens of flowers in the tree, but we began collecting data at the begininning of the season. Perhaps the prior mean should be greater than 0)
  prior(normal(0,5), class = b, coef = Study_night), #slope prior is centered at 0 as we don't assume apriori that we will see changes in flower counts over study nights. Variance is less than the intercept, as we expect growth to be only a portion of the typical number of flowers
  prior(normal(0,5), class = b, coef = Count),
  prior(cauchy(0,10), class = sigma) #standard prior for variance
)

kinks_regression_all_bayes <- brm(Minutes_Per_Hour ~ Study_night + Count,
                                    data = select(as.data.frame(combined_data), !geometry), 
                                    family = "gaussian",
                                    prior = prior2,
                                    warmup =1000, iter = 2000,
                                    refresh = 0)

summary(kinks_regression_all_bayes)
```

As expected, the results of the bayesian regression closely fit the frequentist approach. For this model, we visualize the posterior distributions of the co-efficients for Study Night and Flower Count.

```{r posterior plotting2}
#Get predictions from each sample of the posterior for each night in the study
post_samples <- brms::as_draws_df(kinks_regression_all_bayes)
#determine and plot average predictions with 89% CIs
post_samples %>% 
  pivot_longer(b_Study_night:lp__, names_to = "Coefficient_Type", values_to = "Estimated_Effect") %>%
  filter(Coefficient_Type %in% c("b_Study_night", "b_Count")) %>%
  ggplot() + 
  stat_density_ridges(aes(x = Estimated_Effect, y = Coefficient_Type), scale = 1, quantile_lines = TRUE, quantiles = c(0.055, 0.945)) +
  geom_vline(xintercept = 0, color = "red", linetype = "dashed") +
  theme_classic()
```

Zero is contained with the 89% credible interval of the posterior distributions of either coefficient, thus we do not have sufficient evidence to claim that either the study night or the flower count have an appreciable effect on the nightly residence timesof kinkajous in the balsa crown.

## Analysis of Crown Regions

```{r flower count regression analysis by region}

# using filter function to create new flower data subsets
flowers_R1 <- filter(flower_counts_region, Region == 1) %>% as.data.frame() %>% select(!geom)
flowers_R2 <- filter(flower_counts_region, Region == 2) %>% as.data.frame() %>% select(!geom)
flowers_R3 <- filter(flower_counts_region, Region == 3) %>% as.data.frame() %>% select(!geom)

#predicting flower counts within the regions based on study night

# linear regression flower count region 1
flowers_regression_R1 <- lm(data = flowers_R1, formula = Count ~ Study_night)
summary(flowers_regression_R1)

plot(y = predict(flowers_regression_R1, newdata = data.frame(Study_night = 0:max(flowers_R1$Study_night))), x = 0:max(flowers_R1$Study_night), type = "l",
     xlab = "Study Night",
     ylab = "Flower Count",
     main = "Region 1 Flower Count Regression")
points(x = flowers_R1$Study_night, y = flowers_R1$Count)

plot(x = flowers_R1$Study_night, y = flowers_regression_R1$residuals,
     xlab = "Study Night",
     ylab = "Residuals",
     main = "Region 1 Flower Count Residuals")

Sflower_region1 <- sqrt(sum(flowers_regression_R1$residuals ^ 2)/(length(flowers_regression_R1$residuals) - 2))
qqnorm(flowers_regression_R1$residuals/Sflower_region1)

# linear regression flower count region 2
flowers_regression_R2 <- lm(data = flowers_R2, formula = Count ~ Study_night)
summary(flowers_regression_R2)

plot(y = predict(flowers_regression_R2, newdata = data.frame(Study_night = 0:max(flowers_R2$Study_night))), x = 0:max(flowers_R2$Study_night), type = "l",
     xlab = "Study Night",
     ylab = "Flower Count",
     main = "Region 2 Flower Count Regression")
points(x = flowers_R2$Study_night, y = flowers_R2$Count)

plot(x = flowers_R2$Study_night, y = flowers_regression_R2$residuals,
     xlab = "Study Night",
     ylab = "Residuals",
     main = "Region 2 Flower Count Residuals")

Sflower_region2 <- sqrt(sum(flowers_regression_R2$residuals ^ 2)/(length(flowers_regression_R2$residuals) - 2))
qqnorm(flowers_regression_R2$residuals/Sflower_region2)

# linear regression flower count region 3
flowers_regression_R3 <- lm(data = flowers_R3, formula = Count ~ Study_night)
summary(flowers_regression_R3)

plot(y = predict(flowers_regression_R3, newdata = data.frame(Study_night = 0:max(flowers_R3$Study_night))), x = 0:max(flowers_R3$Study_night), type = "l",
     xlab = "Study Night",
     ylab = "Flower Count",
     main = "Region 3 Flower Count Regression")
points(x = flowers_R3$Study_night, y = flowers_R3$Count)

plot(x = flowers_R3$Study_night, y = flowers_regression_R3$residuals,
     xlab = "Study Night",
     ylab = "Residuals",
     main = "Region 3 Flower Count Residuals")

Sflower_region3 <- sqrt(sum(flowers_regression_R3$residuals ^ 2)/(length(flowers_regression_R3$residuals) - 2))
qqnorm(flowers_regression_R3$residuals/Sflower_region3)
```

```{r residence regression analysis by region}

#predicting kinkajou residence time based on study night and flower count

# combining flower count and residence data containing the regions
combined_data_region <- merge(flower_counts_region, kinkajou_counts_region, by = c("Study_night","Region") , all = TRUE)

R1_data <- filter(combined_data_region, Region == 1)

#linear regression residence time region 1

#R1_Predictions <- predict(residence_region1_regression, newdata = select(R1_data, Count, Study_night))
#plot(x = filter(combined_data_region, Region == 1)$Study_night, y = filter(combined_data_region, Region == 1)$Minutes_Per_Hour, xlab = "Study Night", ylab = "Residence Time", main = "Residence Region 1 Regression") #plot actual residences times by night

#lines(x = filter(combined_data_region, Region == 1)$Study_night, y = R1_Predictions

# residence_region1_regression <- lm(data = R1_data, formula = Minutes_Per_Hour ~ Study_night + Count)
# summary(residence_region1_regression)
# 
# Sres_region1 <- sqrt(sum(residence_region1_regression$residuals ^ 2)/(length(residence_region1_regression$residuals) - 2))
# plot(residence_region1_regression$residuals, xlab = "Index", ylab = "Residuals", main = "Residence Region 1 Regression Residuals")
# qqnorm(residence_region1_regression$residuals/Sres_region1)
# 
# 
# 
# #linear regression residence time region 2
# residence_region2_regression <- lm(data = filter(combined_data_region, Region == 2), formula = Minutes_Per_Hour ~ Study_night + Count)
# summary(residence_region2_regression)
# 
# Sres_region2 <- sqrt(sum(residence_region2_regression$residuals ^ 2)/(length(residence_region2_regression$residuals) - 2))
# plot(residence_region2_regression$residuals, xlab = "Index", ylab = "Residuals", main = "Residence Region 2 Regression Residuals")
# qqnorm(residence_region2_regression$residuals/Sres_region2)
# 
# #linear regression residence time region 3
# residence_region3_regression <- lm(data = filter(combined_data_region, Region == 3), formula = Minutes_Per_Hour ~ Study_night + Count)
# summary(residence_region3_regression)
# 
# Sres_region3 <- sqrt(sum(residence_region3_regression$residuals ^ 2)/(length(residence_region3_regression$residuals) - 2))
# plot(residence_region3_regression$residuals, xlab = "Index", ylab = "Residuals", main = "Residence Region 3 Regression Residuals")
# qqnorm(residence_region3_regression$residuals/Sres_region3)

# combining region regressions into 1 regression
combined_data_region <- mutate(combined_data_region, Total_Flowers = combined_data$Count[pmatch(Study_night, combined_data$Study_night, duplicates.ok = TRUE)])
residence_regression <- lm(data = combined_data_region, formula = Minutes_Per_Hour ~ Count + Region + Total_Flowers)
summary(residence_regression)
# We want to visualize the affect of region and regional flower count, after accounting for the effect of total flower count. TO do this, we substract the modeled effect of total flower count from all of our residence times
combined_data_region = mutate(combined_data_region, Adjusted_Residence = Minutes_Per_Hour - Total_Flowers * residence_regression$coefficients["Total_Flowers"])

ggplot(combined_data_region, aes(x = Count, y = Adjusted_Residence, color = Region)) +
  geom_point() +
  geom_abline(slope = residence_regression$coefficients["Count"], 
            intercept = residence_regression$coefficients["(Intercept)"], colour="firebrick1") + #Region 1
  geom_abline(slope = residence_regression$coefficients["Count"], 
            intercept = (residence_regression$coefficients["(Intercept)"] + residence_regression$coefficients["Region2"]), colour="forestgreen") + #Region 2
  geom_abline(slope = residence_regression$coefficients["Count"], 
            intercept = (residence_regression$coefficients["(Intercept)"] + residence_regression$coefficients["Region3"]), colour="dodgerblue3") + #Region 3
  theme_classic()+
  labs( x = "Regional Flower Count", 
        y = "Adjusted Residence Time")

```
